<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>주소록</title>
    <!-- 폰트 적용 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap" rel="stylesheet">

    <link rel="stylesheet" th:href="@{/css/common/header.css}">
    <link rel="stylesheet" th:href="@{/css/common/footer.css}">
    <link rel="stylesheet" th:href="@{/css/common/style.css}">

    <link rel="stylesheet" th:href="@{/css/addressBook/addressBookMain.css}">

</head>
<body>
<div class="snowfall-container" id="snowContainer"></div>
    <header th:replace="~{/common/header::headerFragment}"></header>


    <section class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-title">주소록</div>
            <ul>
                <li><a href="/addressBook/employeeAddressBook">사내 직원</a></li>
                <li><a href="/addressBook/factoryAddressBook">협력 업체</a></li>
            </ul>
        </div>

        <!-- 메인 컨텐츠 -->
        <div class="main-content">
            <!-- 검색 바 -->
            <div class="top-bar">
                <input type="text" id="search-input" placeholder="이름 또는 부서명 검색">
                <button onclick="searchEmployees()">검색</button>
            </div>

            <!-- 테이블 -->
            <div class="table-header">
                <div class="table-cell">사번</div>
                <div class="table-cell">이름</div>
                <div class="table-cell">부서</div>
                <div class="table-cell">직책</div>
                <div class="table-cell">이메일</div>
                <div class="table-cell">전화번호</div>
            </div>
            <div id="employee-list">
                <!-- 여기에서 검색 결과가 실시간으로 표시됩니다 -->
            </div>

            <!-- 페이지네이션 표시 -->
            <div class="pagination">
                <ul>

                    <!-- 첫 페이지 -->
                    <li class="first">
                        <a href="?page=1"><<</a>
                    </li>
                    <!-- 이전 페이지 -->
                    <li class="prev">
                        <a th:href="@{'/addressBook/employeeAddressBook?page=' + ${prevPage}}" class="prev"><</a>
                    </li>

                    <!-- 페이지 번호들 -->
                    <th:block th:each="i : ${#numbers.sequence(1, totalPages)}">
                        <li th:classappend="${i == currentPage ? 'active' : ''}">
                            <a th:href="@{'/addressBook/employeeAddressBook?page=' + ${i}}" th:text="${i}"></a>
                        </li>
                    </th:block>

                    <!-- 다음 페이지 -->
                    <li class="next">
                        <a th:href="@{'/addressBook/employeeAddressBook?page=' + ${nextPage}}" class="next">></a>
                    </li>
                    <!-- 마지막 페이지 -->
                    <li class="last">
                        <a th:href="@{'/addressBook/employeeAddressBook?page=' + ${totalPages}}" class="last">>></a>
                    </li>
                </ul>
            </div>

        </div>


    </section>
    <footer th:replace="~{/common/footer::footerFragment}"></footer>
<script>
    // 검색 상태 변수
    let debounceTimeout; // 디바운스 타이머
    let preValue = ""; // 이전 검색어

    document.addEventListener('DOMContentLoaded', function () {
        const searchInput = document.getElementById('search-input');

        // 페이지 로드 시 전체 직원 조회 실행
        fetchEmployees();

        // 검색 입력에서 입력할 때마다 실시간 검색 실행
        searchInput.addEventListener('input', (event) => {
            clearTimeout(debounceTimeout); // 이전 타이머 취소
            debounceTimeout = setTimeout(() => {
                const presentValue = event.target.value.trim();
                if (preValue !== presentValue) {
                    if (presentValue === "") {
                        fetchEmployees(); // 입력값이 비어 있으면 전체 조회 실행
                    } else {
                        searchEmployees(presentValue); // 검색어가 변경되었을 때 fetch 실행
                    }
                    preValue = presentValue; // 이전 값 갱신
                }
            }, 200); // 200ms 디바운스
        });
    });

    // 전체 직원 조회 함수
    function fetchEmployees() {
        fetch('/addressBook/employees')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => renderEmployees(data))
            .catch(error => console.error('Error fetching employees:', error));
    }

    // 검색 실행 함수
    function searchEmployees(keyword) {
        fetch(`/addressBook/search?keyword=${keyword}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => renderEmployees(data))
            .catch(error => console.error('Error fetching employees:', error));
    }

    // 데이터를 테이블에 렌더링하는 함수
    function renderEmployees(data) {
        const tableBody = document.getElementById('employee-list');
        tableBody.innerHTML = ""; // 기존 데이터를 초기화

        if (data.length === 0) {
            tableBody.innerHTML = `<div class="table-row">검색 결과가 없습니다.</div>`;
            return;
        }

        data.forEach(employee => {
            const row = document.createElement('div');
            row.className = "table-row";

            function formatPhoneNumber(phoneNumber) {
                if (!phoneNumber) return '';
                return phoneNumber.replace(/(\d{3})(\d{3,4})(\d{4})/, '$1-$2-$3'); // 전화번호 포맷팅
            }

            row.innerHTML = `
            <div class="table-cell">${employee.id}</div>
            <div class="table-cell">${employee.name}</div>
            <div class="table-cell">${employee.deptName}</div>
            <div class="table-cell">${employee.positionName}</div>
            <div class="table-cell">${employee.email}</div>
            <div class="table-cell">${formatPhoneNumber(employee.phone)}</div>
        `;
            tableBody.appendChild(row);
        });
    }







    function createSnowflake() {
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';

        // 랜덤 특성 부여
        const left = Math.random() * 100; // 랜덤 가로 위치
        const size = Math.random() * 10 + 15; // 15-25px 크기
        const duration = Math.random() * 5 + 8; // 8-13초 낙하 시간
        const color = [
            'rgba(176, 224, 230, 0.4)', // 연한 하늘색
            'rgba(173, 216, 230, 0.4)', // 밝은 하늘색
            'rgba(135, 206, 235, 0.4)', // 스카이블루
            'rgba(176, 196, 222, 0.4)', // 연한 스틸블루
            'rgba(188, 212, 230, 0.4)'  // 파스텔 하늘색
        ][Math.floor(Math.random() * 5)];

        // 랜덤 눈송이 모양
        snowflake.innerHTML = ['❄', '✦', '❅', '✧'][Math.floor(Math.random() * 4)];

        // 스타일 적용
        snowflake.style.left = `${left}%`;
        snowflake.style.fontSize = `${size}px`;
        snowflake.style.color = color;
        snowflake.style.animationDuration = `${duration}s`;

        // 약간의 흔들림 효과 추가
        const wobble = Math.random() * 20 - 10;
        snowflake.style.animationName = `snowfall-${wobble}`;

        // 컨테이너에 추가
        document.getElementById('snowContainer').appendChild(snowflake);

        // 애니메이션 끝나면 제거
        setTimeout(() => {
            snowflake.remove();
        }, duration * 1000);
    }

    // 초기 눈송이들 생성
    for(let i = 0; i < 50; i++) {  // 초기눈송이 갯수
        setTimeout(createSnowflake, Math.random() * 8000);  //숫자를 줄이면 더 빠르게 초기 눈송이가 생성됨
                                                            //숫자를 키우면 더 천천히 생성됨
    }

    // 계속해서 새로운 눈송이 생성  클수록 조금
    setInterval(createSnowflake, 800);

    // 눈의 양: setInterval의 시간(150)을 조절
    // 눈의 크기: size 변수의 범위(15-25px) 조절
    // 낙하 속도: duration 변수의 범위(8-13초) 조절
    // 색상: color 배열의 색상들 수정


</script>

</body>
</html>
